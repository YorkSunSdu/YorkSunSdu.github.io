---
layout: post
title: 二叉树（牛客）
date: 2023-05-06
tags: 算法
---

# 二叉树（牛客）

题目来自牛客题目库 [算法篇面试必刷TOP101](https://www.nowcoder.com/exam/oj?page=1&tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=295)。

## BM23 二叉树的前序遍历(简单)

### 题目

[题目链接](https://www.nowcoder.com/practice/5e2135f4d2b14eb8a5b06fab4c938635?tpId=295&tqId=2291302&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

数据范围：二叉树的节点数量满足1≤*n*≤100 ，二叉树节点的值满足1≤*val*≤100 ，树的各节点的值各不相同

示例 1：

<img src="https://uploadfiles.nowcoder.com/images/20211111/392807_1636599059575/FE67E09E9BA5661A7AB9DF9638FB1FAC" alt="img" style="zoom:67%;" />

```
输入：{1,#,2,3}
返回值：[1,2,3]
```

### 解法1 递归

前序遍历：根-左-右

**递归解题三步骤：终止条件、返回值、本级任务。**

- 终止条件：节点为空
- 返回值：空
- 本级任务：根-左-右

```java
import java.util.*;

public class Solution {

    public void preorder(List<Integer> list, TreeNode root){
        // 空节点处理不要忘了
        if(root == null)
            return;
        // add()方法添加元素
        list.add(root.val);
        preorder(list, root.left);
        preorder(list, root.right);
    }
    
    public int[] preorderTraversal (TreeNode root) {
        // list<Integer>是可变长度的数组
        List<Integer> list = new ArrayList();
        preorder(list, root);
        // 可变数组的元素个数用list.size()方法
        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++){
            res[i] = list.get(i);
        }
        return res;
    }
}
```

### 解法2 栈

前序遍历：根-左-右，所以父节点出栈后，子节点入栈顺序是右-左。

```java
import java.util.*;

public class Solution {

    public int[] preorderTraversal (TreeNode root) {
        List<Integer> list = new ArrayList();
        Stack<TreeNode> stk = new Stack<TreeNode>();
        if(root == null)
            // 返回空数组
            return new int[0];
        stk.push(root);
        // 判断栈是否为空的方法stk.isEmpty()
        while(!stk.isEmpty()){
            TreeNode node = stk.pop();
            list.add(node.val);
            if(node.right != null)
                stk.push(node.right);
            if(node.left != null)
                stk.push(node.left);
        }
        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++){
            res[i] = list.get(i);
        }
        return res;
    }
}
```

用栈解决二叉树的后序遍历和前序遍历思路一样，所以先写BM25后序遍历，再写BM24中序遍历。



## BM25 二叉树的后序遍历(简单)

给定一个二叉树，返回他的后序遍历的序列。

后序遍历是值按照 左节点->右节点->根节点 的顺序的遍历。

数据范围：二叉树的节点数量满足1≤*n*≤100 ，二叉树节点的值满足1≤*val*≤100 ，树的各节点的值各不相同

样例图：

![img](https://uploadfiles.nowcoder.com/images/20211111/392807_1636596692486/64547759EAC75079FDBF501CAA589890)

示例：

```
示例1：
输入：{1,#,2,3}
返回值：[3,2,1]
说明：如题面图 
示例2：
输入：{1}
返回值：[1]
```

### 解法1 递归

**递归解题三步骤：终止条件、返回值、本级任务。**

```java
import java.util.*;

public class Solution {

    public void postorder(List list, TreeNode node) {
        // 空节点处理不要忘了
        if(node == null)
            return ;
        postorder(list, node.left);
        postorder(list, node.right);
        list.add(node.val);
    }

    public int[] postorderTraversal (TreeNode root) {
        List<Integer> list = new ArrayList();
        postorder(list, root);
        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        return res;
    }
}
```

### 解法2 栈

前序遍历是根-左-右，先变成根-右-左，再反转为左-右-根，即后序遍历。

```java
import java.util.*;

public class Solution {

    public int[] postorderTraversal (TreeNode root) {
        if(root == null)
            return new int[0];
        List<Integer> list = new ArrayList();
        Stack<TreeNode> stk = new Stack<TreeNode>();
        stk.push(root);
        while(!stk.isEmpty()){
            TreeNode node = stk.pop();
            list.add(node.val);
            if(node.left != null)
                stk.push(node.left);
            if(node.right != null)
                stk.push(node.right);
        }
        // 用下面的方式反转List
        Collections.reverse(list);
        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++){
            res[i] = list.get(i);
        }
        return res;
    }
}
```



## BM24 二叉树的中序遍历(中等)

中等的原因是用栈迭代。

### 题目

[题目链接](https://www.nowcoder.com/practice/0bf071c135e64ee2a027783b80bf781d?tpId=295&tqId=1512964&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

给定一个二叉树的根节点root，返回它的中序遍历结果。

数据范围：树上节点数满足0≤*n*≤1000，树上每个节点的值满足−1000≤*val*≤1000
进阶：空间复杂度O*(*n)，时间复杂度O(n)

示例：

```
示例1：
输入：{1,2,#,#,3}
返回值：[2,3,1]
示例2：
输入：{1,2}
返回值：[2,1]
示例3：
输入：{}
返回值：[]
示例4：
输入：{1,#,2}
返回值：[1,2]

备注：
树中节点数目在范围[0, 100]内
树中的节点的值在[-100,100]以内
```

### 解法1 递归

**递归解题三步骤：终止条件、返回值、本级任务。**

```java
import java.util.*;

public class Solution {

    public void inorder(List list, TreeNode node){
        if(node == null)
            return ;
        inorder(list, node.left);
        list.add(node.val);
        inorder(list, node.right);
    }
    public int[] inorderTraversal (TreeNode root) {
        List<Integer> list = new ArrayList();
        inorder(list, root);
        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++){
            res[i] = list.get(i);
        }
        return res;
    }
}
```

### 解法2 栈

使用指针cur指向节点，用来访问节点。

```java
import java.util.*;

public class Solution {

    public int[] inorderTraversal (TreeNode root) {
        if(root == null)
            return new int[0];
        List<Integer> list = new ArrayList();
        Stack<TreeNode> stk = new Stack<TreeNode>();
        TreeNode cur = root;
        // 当前指针指向的节点不为空，或栈不为空时
        while(cur != null || !stk.isEmpty()){
            // 处理左子树
            while(cur != null) {
                stk.push(cur);
                cur = cur.left;
            }
            // 处理父节点
            TreeNode node = stk.pop();
            list.add(node.val);
            // 处理右子树
            cur = node.right;
        }
        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++){
            res[i] = list.get(i);
        }
        return res;
    }
}
```



## BM26 求二叉树的层序遍历(简单)

### 题目

[题目链接](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=295&tqId=644&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）
例如：
给定的二叉树是{3,9,20,#,#,15,7},
<img src="https://uploadfiles.nowcoder.com/images/20210114/999991351_1610616074120/036DC34FF19FB24652AFFEB00A119A76" alt="img" style="zoom:50%;" />
该二叉树层序遍历的结果是
[
[3],
[9,20],
[15,7]

]

提示:

0 <= 二叉树的结点数 <= 1500

示例：

```
示例1：
输入：{1,2}
返回值：[[1],[2]]
示例2：
输入：{1,2,3,4,#,#,5}
返回值：[[1],[2,3],[4,5]]
```

### 解法1 队列

使用队列储存二叉树节点。记录二叉树每一层的节点数目。

```java
import java.util.*;

public class Solution {

    public ArrayList<ArrayList<Integer>> levelOrder (TreeNode root) {
        // 注意声明的语句
        ArrayList<ArrayList<Integer>> res = new ArrayList();
        if(root == null)
            return res;
        // 使用队列，注意声明的语句
        Queue<TreeNode> q = new ArrayDeque<TreeNode>();
        q.add(root);
        while(!q.isEmpty()){
            ArrayList<Integer> row = new ArrayList();
            // 层序遍历需要记录当前层的节点数目
            int n = q.size();
            for(int i = 0; i < n; i++){
                // 注意队列的操作poll()
                TreeNode cur = q.poll();
                row.add(cur.val);
                if(cur.left != null)
                    q.add(cur.left);
                if(cur.right != null)
                    q.add(cur.right);
            }
            // 注意给二维数组赋值的操作
            res.add(row);
        }
        return res;
    }
}
```

### 解法2 递归

**递归解题三步骤：终止条件、返回值、本级任务。**

- 终止条件：节点为空
- 返回值：空
- 本级任务：处理当前层

```java
import java.util.*;

public class Solution {

    ArrayList<ArrayList<Integer>> res = new ArrayList();

    void traverse(TreeNode root, int depth) {
        if(root == null)
            return ;
        // 新的一层，加一层
        if(res.size() < depth){
            ArrayList<Integer> row = new ArrayList();
            res.add(row);
            row.add(root.val);
        }
        // 不是新的一层，先获取所在的层，再把节点值加到层末尾
        else {
            ArrayList<Integer> row = res.get(depth - 1);
            row.add(root.val);
        }
        // 遍历左右子树
        traverse(root.left, depth + 1);
        traverse(root.right, depth + 1);
    }

    public ArrayList<ArrayList<Integer>> levelOrder (TreeNode root) {
        if(root == null)
            return res;
        traverse(root, 1);
        return res;
    }
}
```



## BM27 按之字形顺序打印二叉树(中等)

### 题目

[题目链接](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=295&tqId=23454&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）

数据范围：0≤*n*≤1500,树上每个节点的val满足∣*val*∣<=1500
要求：空间复杂度: O(n)，时间复杂度：O(n)

例如：
给定的二叉树是{1,2,3,#,#,4,5}

<img src="https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05" alt="img" style="zoom:80%;" />

该二叉树之字形层序遍历的结果是

[

[1],

[3,2],

[4,5]

]

示例：

```
示例1：
输入：{1,2,3,#,#,4,5}
返回值：[[1],[3,2],[4,5]]
说明：如题面解释，第一层是根节点，从左到右打印结果，第二层从右到左，第三层从左到右。 
示例2：
输入：{8,6,10,5,7,9,11}
返回值：[[8],[10,6],[5,7,9,11]]
示例3：
输入：{1,2,3,4,5}
返回值：[[1],[3,2],[4,5]]
```

### 解法1 队列

和层序遍历一样，但隔一层反转一次。

```java
import java.util.*;

public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> res = new ArrayList();
        if (pRoot == null)
            return res;
        int num = 0;
        Queue<TreeNode> q = new ArrayDeque<TreeNode>();
        q.add(pRoot);
        while (!q.isEmpty()) {
            ArrayList<Integer> row = new ArrayList();
            num++;
            int n = q.size();
            for (int i = 0; i < n; i++) {
                TreeNode cur = q.poll();
                row.add(cur.val);
                if (cur.left != null)
                    q.add(cur.left);
                if (cur.right != null)
                    q.add(cur.right);
            }
            // 反转
            if (num % 2 == 0)
                Collections.reverse(row);
            res.add(row);
        }
        return res;
    }
}
```

### 解法2 栈

和层序遍历一样，但隔一层反转一次

```java
import java.util.*;

public class Solution {
    ArrayList<ArrayList<Integer>> res = new ArrayList();

    void traverse(TreeNode root, int depth) {
        if (root == null)
            return ;
        if (res.size() < depth) {
            ArrayList<Integer> row = new ArrayList();
            res.add(row);
            row.add(root.val);
        } else {
            ArrayList<Integer> row = res.get(depth - 1);
            row.add(root.val);

        }
        traverse(root.left, depth + 1);
        traverse(root.right, depth + 1);
    }

    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        if (pRoot == null)
            return res;
        traverse(pRoot, 1);
        // 反转
        for (int i = 0; i < res.size(); i++) {
            if (i % 2 == 1) {
                Collections.reverse(res.get(i));
            }
        }
        return res;
    }
}
```



## BM28 二叉树的最大深度(简单)

### 题目

求给定二叉树的最大深度，

深度是指树的根节点到任一叶子节点路径上节点的数量。

最大深度是所有叶子节点的深度的最大值。

（注：叶子节点是指没有子节点的节点。）

数据范围：0≤*n*≤100000，树上每个节点的val满足∣*val*∣≤100
要求： 空间复杂度O(1), 时间复杂度O(n)

### 解法1 递归

**递归解题三步骤：终止条件、返回值、本级任务。**

- 终止条件：根节点为空
- 返回值：int
- 本级任务：求当前层的最大深度

```java
import java.util.*;

public class Solution {

    public int maxDepth (TreeNode root) {
        if(root == null)
            return 0;
        // 求两个数的较大值
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

### 解法2 层序遍历

```java
import java.util.*;

public class Solution {

    public int maxDepth (TreeNode root) {
        if(root == null)
            return 0;
        Queue<TreeNode> q = new ArrayDeque<TreeNode>();
        q.add(root);
        int depth = 0;
        while(!q.isEmpty()) {
            int n = q.size();
            for(int i = 0; i < n; i++) {
                TreeNode node = q.poll();
                if(node.left != null)
                    q.add(node.left);
                if(node.right != null)
                    q.add(node.right);
            }
            depth++;
        }
        return depth;
    }
}
```



## BM29 二叉树中和为某一值的路径(一)(简单)

### 题目

给定一个二叉树root和一个值 sum，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。

1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点

2.叶子节点是指没有子节点的节点

3.路径只能从父节点到子节点，不能从子节点到父节点

4.总节点数目为n

例如：
给出如下的二叉树，sum=22，

<img src="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159" alt="img" style="zoom: 80%;" />

返回true，因为存在一条路径 5→4→11→2的节点值之和为 22

数据范围：

1.树上的节点数满足0≤*n*≤10000

2.每 个节点的值都满足∣*val*∣≤1000

要求：空间复杂度O(n) ，时间复杂度O(n)

进阶：空间复杂度O(树的高度)，时间复杂度O(n)

示例：

```
示例1：
输入：{5,4,8,1,11,#,9,#,#,2,7},22
返回值：true
示例2：
输入：{1,2},0
返回值：false
示例3：
输入：{1,2},3
返回值：true
示例4：
输入：{},0
返回值：false
```

### 解法1 递归

**递归解题三步骤：终止条件、返回值、本级任务。**

- 终止条件：找到一条路径和为sum，或根节点为空(没有找到和为sum的路径)。

```java
import java.util.*;

public class Solution {

    public boolean hasPathSum (TreeNode root, int sum) {
        if(root == null)
            return false;
        if(root.left == null && root.right == null && sum - root.val == 0)
            return true;
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    }
}
```

### 解法2 栈、深度优先

**图示：**

<img src="https://uploadfiles.nowcoder.com/images/20211204/397721558_1638591916283/D33422A0A2A416179193EAF5EBD60154" alt="alt" style="zoom: 33%;" />

```java
import java.util.*;

public class Solution {

    public boolean hasPathSum (TreeNode root, int sum) {
        if(root == null)
            return false;
        // 一个栈储存树的节点
        Stack<TreeNode> stk1 = new Stack<TreeNode>();
        // 一个栈储存到当前节点的加和
        Stack<Integer> stk2 = new Stack<Integer>();
        stk1.push(root);
        stk2.push(root.val);
        while(!stk1.empty()) {
            TreeNode node = stk1.pop();
            int n = stk2.pop();
            if(node.left == null && node.right == null && n == sum)
                return true;
            if(node.left != null) {
                stk1.push(node.left);
                stk2.push(n + node.left.val);
            }
            if(node.right != null) {
                stk1.push(node.right);
                stk2.push(n + node.right.val);
            }
        }
        return false;
    }
}
```



## BM30 二叉搜索树与双向链表(中等) ？？没看懂

### 题目

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示

<img src="https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2" alt="img" style="zoom: 33%;" />

数据范围：输入二叉树的节点数0≤*n*≤1000，二叉树中每个节点的值0≤*val*≤1000
要求：空间复杂度O(1)（即在原树上操作），时间复杂度O(n)

注意:

1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继
2.返回链表中的第一个节点的指针
3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构

4.你不用输出双向链表，程序会根据你的返回值自动打印输出

**输入描述：**

二叉树的根节点

**返回值描述：**

双向链表的其中一个头节点。

示例：

```
示例1：
输入：{10,6,14,4,8,12,16}
返回值：From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;
说明：输入题面图中二叉树，输出的时候将双向链表的头节点返回即可。
示例2：
输入：{5,4,#,3,#,2,#,1}
返回值：From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1;
说明：
                    5
                  /
                4
              /
            3
          /
        2
      /
    1
树的形状如上图  
```

### 解法1 递归中序遍历

**递归解题三步骤：终止条件、返回值、本级任务。**

- 终止条件：
- 返回值：
- 本级任务：

```java
public class Solution {
    // 头节点(返回值)
    public TreeNode head = null;
    // 中序遍历当前值的上一位
    public TreeNode pre = null;
    public TreeNode Convert(TreeNode pRootOfTree) {
        if(pRootOfTree == null)
            return null;
        // 递归找到最小值
        Convert(pRootOfTree.left);
        // 初始化
        if(pre == null){
            head = pRootOfTree;
            pre = pRootOfTree;
        }
        else{
            // 已经处理完左边了，准备处理上一节点的右节点
            pre.right = pRootOfTree;
            pRootOfTree.left = pre;
            pre = pRootOfTree;
        }
        Convert(pRootOfTree.right);
        return head;
    }
}
```

### 解法2 栈



## BM31 对称的二叉树(简单)

### 题目

[题目链接](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=295&tqId=23452&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）
例如：下面这棵二叉树是对称的
![img](https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F)
下面这棵二叉树不对称。
![img](https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642770481/3304ABDD147D8E140B2CEF3201BD8372)

数据范围：节点数满足0≤*n*≤1000，节点上的值满足∣*val*∣≤1000

要求：空间复杂度 O(n)，时间复杂度O(n)

备注：

你可以用递归和迭代两种方法解决这个问题

示例：

```
示例1：
输入：{1,2,2,3,4,4,3}
返回值：true
示例2：
输入：{8,6,9,5,7,7,5}
返回值：false
```

### 解法1 递归

**递归解题三步骤：终止条件、返回值、本级任务。**

- 终止条件： 当进入子问题的两个节点都为空，说明都到了叶子节点，且是同步的，因此结束本次子问题，返回true；当进入子问题的两个节点只有一个为空，或是元素值不相等，说明这里的对称不匹配，同样结束本次子问题，返回false。
- 返回值： 每一级将子问题是否匹配的结果往上传递。
- 本级任务： 每个子问题，需要按照上述思路，“根左右”走左边的时候“根右左”走右边，“根左右”走右边的时候“根右左”走左边，一起进入子问题，需要两边都是匹配才能对称。

```java
public class Solution {

    boolean recursion(TreeNode root1, TreeNode root2){
        // 都为空
        if(root1 == null && root2 == null)
            return true;
        // 其中一个为空，或者都非空且值不相等
        if(root1 == null || root2 == null || root1.val != root2.val)
            return false;
        return recursion(root1.left, root2.right) && recursion(root1.right, root2.left);
    }

    boolean isSymmetrical(TreeNode pRoot) {
        return recursion(pRoot, pRoot);
    }
}
```

### 解法2 迭代、层序遍历

边迭代边检查是否对称。

```java
import java.util.*;

public class Solution {
    boolean isSymmetrical(TreeNode pRoot) {
        if(pRoot == null)
            return true;
        // 一定记住初始化队列的时候右边是LinkedList或者ArrayDeque，不是Queue
        Queue<TreeNode> q1 = new LinkedList<TreeNode>();
        Queue<TreeNode> q2 = new LinkedList<TreeNode>();
        q1.add(pRoot.left);
        q2.add(pRoot.right);
        while(!q1.isEmpty() && !q2.isEmpty()){
            TreeNode left = q1.poll();
            TreeNode right = q2.poll();
            // 都为空
            if(left == null && right == null)
                continue;
            // 其中一个为空，或者都非空且值不相等
            if(left == null || right == null || left.val != right.val)
                return false;
            q1.add(left.left);
            q1.add(left.right);
            q2.add(right.right);
            q2.add(right.left);
        }
        return true;
    }
}

```

**附错误解法：**左子树按左-根-右遍历，右子树按右-根-左遍历，比较遍历结果。

```java
import java.util.*;

public class Solution {

    void normalOrder(List list, TreeNode root) {
        if(root == null)
            return ;
        normalOrder(list, root.left);
        list.add(root.val);
        normalOrder(list, root.right);
    }

    void reverseOrder(List list, TreeNode root){
        if(root == null)
            return ;        
        reverseOrder(list, root.right);
        list.add(root.val);
        reverseOrder(list, root.left);
    }

    boolean isSymmetrical(TreeNode pRoot) {
        if(pRoot == null)
            return true;
        ArrayList<Integer> list1 = new ArrayList();
        ArrayList<Integer> list2 = new ArrayList();
        normalOrder(list1, pRoot.left);
        reverseOrder(list2, pRoot.right);
        if(list1.size() != list2.size())
            return false;
        for(int i = 0; i < list1.size(); i++){
            if(list1.get(i) != list2.get(i))
                return false;
        }
        return true;
        
    }
}
```

错误之处在于：一次遍历的结果不能确定树的结构，总有测试用例能满足遍历结果相同，但实际上树的结构并不相同。所以应该边迭代边检查。



## BM32 合并二叉树(简单)

### 题目

[题目链接](https://www.nowcoder.com/practice/7298353c24cc42e3bd5f0e0bd3d1d759?tpId=295&tqId=1025038&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj)

已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：
两颗二叉树是:
                                  Tree 1

![img](https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821337680/9E290CFD3730B9B08A5CEFF25799608F)

​                                    Tree 2
![img](https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821376266/DD0A63560E770A8510049C5182E6E622)
​                                  合并后的树为
![img](https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821404541/9CB750F8909D5985C0D01D8B71AD58BA)

数据范围：树上节点数量满足0≤*n*≤500，树上节点的值一定在32位整型范围内。

进阶：空间复杂度 O(1) ，时间复杂度O(n)

示例：

```
示例1：
输入：{1,3,2,5},{2,1,3,#,4,#,7}
返回值：{3,4,5,5,4,#,7}
说明：如题面图 
示例2：
输入：{1},{}
返回值：{1}
```

### 解法



```java

```



## 总结

普通遍历用栈，层序遍历用队列。

递归在树的题目中很常用。

**递归解题三步骤：终止条件、返回值、本级任务。**