---
layout: post
title: 动态规划（牛客）
date: 2023-06-21
tags: 算法
---

# 动态规划（牛客）

题目来自牛客题目库 [算法篇面试必刷TOP101](https://www.nowcoder.com/exam/oj?page=1&tab=%E7%AE%97%E6%B3%95%E7%AF%87&topicId=295)。

## BM62 斐波那契数列(入门)

### 题目

略。

### 解法1 递归

```Java
import java.util.*;

public class Solution {

    public int Fibonacci (int n) {
        if(n == 1 || n == 2)
            return 1;
        return Fibonacci(n - 1) + Fibonacci(n - 2);
    }
}
```

时间复杂度 O(2^n^), 空间复杂度 O(n)

### 解法2 动态规划

```Java
public class Solution {
    public int Fibonacci(int n) {
        //从0开始，第0项是0，第一项是1
        if(n <= 1)    
             return n;
         int res = 0;
         int a = 0;
         int b = 1;
         //因n=2时也为1，初始化的时候把a=0，b=1
         for (int i = 2; i <= n; i++){
         //第三项开始是前两项的和,然后保留最新的两项，更新数据相加
             res = (a + b);
             a = b;
             b = res;
         }
        return res;
    }
}
```

时间复杂度 O(n), 空间复杂度O(1)



## BM63 跳台阶(简单)

### 题目

[题目链接](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=295&tqId=23261&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

数据范围：1≤*n*≤40

要求：时间复杂度：O(n) ，空间复杂度：O(1)

示例：

```
示例1：
输入：2
返回值：2
说明：青蛙要跳上两级台阶有两种跳法，分别是：先跳一级，再跳一级或者直接跳两级。因此答案为2 
示例2：
输入：7
返回值：21
```

### 解法1 记忆化搜索

用数组自下而上计算。

```Java
import java.util.*;

public class Solution {

    int[] dp = new int[50];
    public int jumpFloor (int number) {
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= number; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[number];
    }
}
```

时间复杂度 O(n), 空间复杂度O(n)

### 解法2 动态规划

对上个解法进一步优化。

```Java
import java.util.*;

public class Solution {

    public int jumpFloor (int number) {
        int a = 1, b = 1, c = 1;
        for(int i = 2; i <= number; i++) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
}
```

时间复杂度 O(n), 空间复杂度O(1)



## BM64 最小花费爬楼梯(简单)

### 题目

[题目链接](https://www.nowcoder.com/practice/6fe0302a058a4e4a834ee44af88435c7?tpId=295&tqId=2366451&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

给定一个整数数组 cost ，其中 cost[i] 是从楼梯第*i* 个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

数据范围：数组长度满足 1≤*n*≤10^5^ ，数组中的值满足 1≤ cost[i] ≤10^4^

示例：

```
示例1：
输入：[2,5,20]
返回值：5
说明：你将从下标为1的台阶开始，支付5 ，向上爬两个台阶，到达楼梯顶部。总花费为5 
示例2：
输入：[1,100,1,1,1,90,1,1,80,1]
返回值：6
说明：你将从下标为 0 的台阶开始。
1.支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
2.支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
3.支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
4.支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
5.支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
6.支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。 
```

###  解法 动态规划

```Java
import java.util.*;

public class Solution {

    public int minCostClimbingStairs (int[] cost) {
        int[] dp = new int[cost.length + 1];
        for(int i = 2; i <= cost.length; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[cost.length];
    }
}
```

时间复杂度 O(n), 空间复杂度O(n)



## BM65 最长公共子序列(二)(中等)

### 题目

[题目链接](https://www.nowcoder.com/practice/6d29638c85bb4ffd80c020fe244baf11?tpId=295&tqId=991075&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回"-1"。目前给出的数据，仅仅会存在一个最长的公共子序列

数据范围：0≤∣*str*1∣,∣*str*2∣≤2000

要求：空间复杂度 O(n^2^) ，时间复杂度 O(n^2^) 

示例：

```
示例1：
输入："1A2C3D4B56","B1D23A456A"
返回值："123456"
示例2：
输入："abc","def"
返回值："-1"
示例3：
输入："abc","abc"
返回值："abc"
示例4：
输入："ab",""
返回值："-1"
```

### 解法 动态规划、递归

```Java
import java.util.*;
public class Solution {
    private String x = "";
    private String y = "";
    //获取最长公共子序列
    String ans(int i, int j, int[][] b){ 
        String res = "";
        //递归终止条件
        if(i == 0 || j == 0)
            return res;
        //根据方向，往前递归，然后添加本级字符
        if(b[i][j] == 1){
            res += ans(i - 1, j - 1, b);
            res += x.charAt(i - 1);
        }
        else if(b[i][j] == 2)
            res += ans(i - 1, j, b);
        else if(b[i][j] == 3)
            res += ans(i,j - 1, b);
        return res;
    }
    public String LCS (String s1, String s2) {
        //特殊情况
        if(s1.length() == 0 || s2.length() == 0)
            return "-1";
        int len1 = s1.length();
        int len2 = s2.length();
        // 局部变量赋给类变量，使ans方法可以访问字符串
        x = s1;
        y = s2;
        //dp[i][j]表示第一个字符串到第i位，第二个字符串到第j位为止的最长公共子序列长度
        int[][] dp = new int[len1 + 1][len2 + 1];
        //动态规划数组相加的方向
        int[][] b = new int[len1 + 1][len2 + 1];
        //遍历两个字符串每个位置求的最长长度
        for(int i = 1; i <= len1; i++){
            for(int j = 1; j <= len2; j++){
                //遇到两个字符相等
                if(s1.charAt(i - 1) == s2.charAt(j - 1)){
                    //考虑由二者都向前一位
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    //来自于左上方
                    b[i][j] = 1;
                }
                //遇到的两个字符不同
                else{
                    //左边的选择更大，即第一个字符串后退一位
                    if(dp[i - 1][j] > dp[i][j - 1]){
                        dp[i][j] = dp[i - 1][j];
                        //来自于左方
                        b[i][j] = 2;
                    }
                    //右边的选择更大，即第二个字符串后退一位
                    else{
                        dp[i][j] = dp[i][j - 1];
                        //来自于上方
                        b[i][j] = 3;
                    }
                }
            }
        }
        //获取答案字符串
        String res = ans(len1, len2, b);
        //检查答案是否位空
        if(res.isEmpty()) 
            return "-1";
        else
            return res;
    }
}
```

时间复杂度 O(n^2^), 空间复杂度O(n^2^)



## BM66 最长公共子串(中等)

### 题目

[题目链接](https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=295&tqId=991150&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

给定两个字符串str1和str2,输出两个字符串的最长公共子串

题目保证str1和str2的最长公共子串存在且唯一。 

数据范围： 1≤∣*str*1∣,∣*str*2∣≤5000
要求： 时间复杂度 O(n^2^), 空间复杂度O(n^2^)

示例：

```
输入："1AB2345CD","12345EF"
返回值："2345"
```

**注：**本题求“最长公共子串”，注意和上题求“最长公共子序列”区分。

### 解法 动态规划

```Java
import java.util.*;
public class Solution {
    public String LCS (String str1, String str2) {
        //dp[i][j]表示到str1第i个个到str2第j个为止的公共子串长度
        int[][] dp = new int[str1.length() + 1][str2.length() + 1]; 
        int max = 0;
        int pos = 0;
        for(int i = 1; i <= str1.length(); i++){
            for(int j = 1; j <= str2.length(); j++){
                //如果该两位相同
                if(str1.charAt(i - 1) == str2.charAt(j - 1)) 
                    //则增加长度
                    dp[i][j] = dp[i - 1][j - 1] + 1; 
                else 
                    //该位置为0
                    dp[i][j] = 0; 
                //更新最大长度
                if(dp[i][j] > max){ 
                    max = dp[i][j];
                    pos = i;
                }
            }
        }
        return str1.substring(pos - max, pos);
    }
}
```

时间复杂度 O(n^2^), 空间复杂度O(n^2^)



## BM67 不同路径的数目(一)(简单)

### 题目

[题目链接](https://www.nowcoder.com/practice/166eaff8439d4cd898e3ba933fbc6358?tpId=295&tqId=685&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

一个机器人在m×n大小的地图的左上角（起点）。

机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。

可以有多少种不同的路径从起点走到终点？

<img src="https://uploadfiles.nowcoder.com/images/20201210/999991351_1607596327517/873CB1F2327F70DA0CA0FDC797F894A7" alt="img" style="zoom:67%;" />

备注：m和n小于等于100,并保证计算结果在int范围内

数据范围：0<*n*,*m*≤100，保证计算结果在32位整型范围内

要求：空间复杂度 O(n\*m)，时间复杂度 O(n\*m)

进阶：空间复杂度 O(1)，时间复杂度 O(min(m, n))

示例：

```
示例1：
输入：2,1
返回值：1
示例2：
输入：2,2
返回值：2
```

### 解法1 递归

```Java
import java.util.*;
public class Solution {
    public int uniquePaths (int m, int n) {
        //矩阵只要有一条边为1，路径数就只有一种了
        if(m == 1 || n == 1) 
            return 1;
        //两个分支
        return uniquePaths(m - 1, n) + uniquePaths(m, n - 1); 
    }
}
```

空间复杂度 O(n+m)，时间复杂度 O(n\*m)

### 解法2 动态规划

```Java
import java.util.*;

public class Solution {

    public int uniquePaths (int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == 1 || j == 1)
                    dp[i][j] = 1;
                else
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m][n];
    }
}
```

空间复杂度 O(n\*m)，时间复杂度 O(n\*m)



## BM68 矩阵的最小路径和(中等)

### 题目

给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。

数据范围: 1≤*n*,*m*≤500，矩阵中任意值都满足 0≤a~i,j~≤100

要求：时间复杂度 O(n\*m)

例如：当输入[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]时，对应的返回值为12，

所选择的最小累加和路径如下图所示：

<img src="https://uploadfiles.nowcoder.com/images/20220122/423483716_1642823916509/06EB123C153852AF55ED51448BEAD1BA" alt="img" style="zoom:67%;" />

示例：

```
示例1：
输入：[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]
返回值：12
示例2：
输入：[[1,2,3],[1,2,3]]
返回值：7
```

### 解法 动态规划

```Java
import java.util.*;
public class Solution {
    public int minPathSum (int[][] matrix) {
        int n = matrix.length;
        //因为n,m均大于等于1
        int m = matrix[0].length;  
        //dp[i][j]表示以当前i，j位置为终点的最短路径长度
        int[][] dp = new int[n][m];
        dp[0][0] = matrix[0][0];
        //处理第一列
        for(int i = 1; i < n; i++)
            dp[i][0] = matrix[i][0] + dp[i - 1][0];
        //处理第一行
        for(int j = 1; j < m; j++)
            dp[0][j] = matrix[0][j] + dp[0][j - 1];
        //其他按照公式来
        for(int i = 1; i < n; i++){ 
          for(int j = 1; j < m; j++){
              dp[i][j] = matrix[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);
          }
      }
       return dp[n - 1][m - 1];
    }
}
```



## BM69 把数字翻译成字符串(中等)

### 题目

有一种将字母编码成数字的方式：'a'->1, 'b->2', ... , 'z->26'。

现在给一串数字，返回有多少种可能的译码结果

数据范围：字符串长度满足 0<*n*≤90

进阶：空间复杂度 O(n)，时间复杂度 O(n)

示例：

```
示例1：
输入："12"
返回值：2
说明：2种可能的译码结果（”ab” 或”l”）
示例2：
输入："31717126241541717"
返回值：192
说明：192种可能的译码结果 
```

### 解法 动态规划

```Java
import java.util.*;
public class Solution {
    public int solve (String nums) {
        //排除0
        if(nums.equals("0"))  
            return 0;
        //排除只有一种可能的10 和 20
        if(nums == "10" || nums == "20")  
            return 1;
        //当0的前面不是1或2时，无法译码，0种
        for(int i = 1; i < nums.length(); i++){  
            if(nums.charAt(i) == '0')
                if(nums.charAt(i - 1) != '1' && nums.charAt(i - 1) != '2')
                    return 0;
        }
        int[] dp = new int[nums.length() + 1];
        //辅助数组初始化为1
        Arrays.fill(dp, 1);  
        for(int i = 2; i <= nums.length(); i++){
            //在11-19，21-26之间的情况
            if((nums.charAt(i - 2) == '1' && nums.charAt(i - 1) != '0') || (nums.charAt(i - 2) == '2' && nums.charAt(i - 1) > '0' && nums.charAt(i - 1) < '7'))
               dp[i] = dp[i - 1] + dp[i - 2];
            else
                dp[i] = dp[i - 1];
        }
        return dp[nums.length()];
    }
}
```



## BM70 兑换零钱(一)(中等)

### 题目

[题目链接](https://www.nowcoder.com/practice/3911a20b3f8743058214ceaa099eeb45?tpId=295&tqId=988994&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。

如果无解，请返回-1.

数据范围：数组大小满足 0≤*n*≤10000 ， 数组中每个数字都满足 0<*val*≤10000，0≤*aim*≤5000

要求：时间复杂度 O(n\*aim) ，空间复杂度 O(aim)。

示例：

```
示例1：
输入：[5,2,3],20
返回值：4
示例2：
输入：[5,2,3],0
返回值：0
示例3：
输入：[3,5],2
返回值：-1
```

### 解法 动态规划

```Java
import java.util.*;
public class Solution {
    public int minMoney (int[] arr, int aim) {
        //小于1的都返回0
        if(aim < 1) 
            return 0;
        int[] dp = new int[aim + 1];
        //dp[i]表示凑齐i元最少需要多少货币数
        Arrays.fill(dp, aim + 1); 
        dp[0] = 0; 
        //遍历1-aim元
        for(int i = 1; i <= aim; i++){ 
            //每种面值的货币都要枚举
            for(int j = 0; j < arr.length; j++){ 
                //如果面值不超过要凑的钱才能用
                if(arr[j] <= i) 
                    //维护最小值
                    dp[i] = Math.min(dp[i], dp[i - arr[j]] + 1); 
            }
        }
        //如果最终答案大于aim代表无解
        return dp[aim] > aim ? -1 : dp[aim]; 
    }
}
```

时间复杂度 O(n\*aim) ，空间复杂度 O(aim)。



## BM71 最长上升子序列(一)(中等)

### 题目

[题目链接](https://www.nowcoder.com/practice/5164f38b67f846fb8699e9352695cd2f?tpId=295&tqId=2281434&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

给定一个长度为 n 的数组 arr，求它的最长严格上升子序列的长度。

所谓子序列，指一个数组删掉一些数（也可以不删）之后，形成的新数组。例如 [1,5,3,7,3] 数组，其子序列有：[1,3,3]、[7] 等。但 [1,6]、[1,3,5] 则不是它的子序列。

我们定义一个序列是 **严格上升** 的，当且仅当该序列**不存在**两个下标 i 和 *j* 满足 i*<*j 且 arr~i~≥ arr~j~

数据范围： 0≤*n*≤1000

要求：时间复杂度 O(n^2^)， 空间复杂度 O(n)

示例：

```
输入：[6,3,1,5,2,3,7]
返回值：4
说明：该数组最长上升子序列为 [1,2,3,7] ，长度为4
```

### 解法 动态规划

```Java
import java.util.*;
public class Solution {
    public int LIS (int[] arr) {
        if(arr.length == 0)
            return 0;
        int[] dp = new int[arr.length];
        //设置数组长度大小的动态规划辅助数组
        Arrays.fill(dp, 1); 
        int res = 1;
        for(int i = 1; i < arr.length; i++){
            for(int j = 0; j < i; j++){
                //可能j不是所需要的最大的，因此需要dp[i] < dp[j] + 1
                if(arr[i] > arr[j] && dp[i] < dp[j] + 1){
                    //i点比j点大，理论上dp要加1
                    dp[i] = dp[j] + 1; 
                    //找到最大长度
                    res = Math.max(res, dp[i]); 
                }
            }
        }
        return res;
    }
}
```



## BM72 连续子数组的最大和(简单)

### 题目

[题目链接](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=295&tqId=23259&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为1。求所有子数组的和的最大值。

数据范围:

1<=*n*<=2×10^5^

−100<=*a*[*i*]<=100

要求:时间复杂度为 O(n)，空间复杂度为 O(n)

进阶:时间复杂度为 O(n)，空间复杂度为 O(1)

示例：

```
示例1：
输入：[1,-2,3,10,-4,7,2,-5]
返回值：18
说明：经分析可知，输入数组的子数组[3,10,-4,7,2]可以求得最大和为18
示例2：
输入：[2]
返回值：2
示例3：
输入：[-10]
返回值：-10
```

### 解法1 动态规划

```Java
public int FindGreatestSumOfSubArray(int[] array) {
        int[] dp = new int[array.length];
        int max = array[0];
        dp[0] = array[0];
        for(int i=1;i<array.length;i++){
            // 动态规划，状态转移方程，确定dp[i]的最大值
            dp[i] = Math.max(dp[i-1] + array[i], array[i]);
            // 每次比较，保存出现的最大值
            max = Math.max(max,dp[i]);
        }
        return max;
    }
```

时间复杂度为 O(n)，空间复杂度为 O(n)

### 解法2 动态规划

```Java
public int FindGreatestSumOfSubArray(int[] array) {
        int sum = 0;
        int max = array[0];
        for(int i=0;i<array.length;i++){
            // 优化动态规划，确定sum的最大值
            sum = Math.max(sum + array[i], array[i]);
            // 每次比较，保存出现的最大值
            max = Math.max(max,sum);
        }
        return max;
}
```

时间复杂度为 O(n)，空间复杂度为 O(1)



## BM73 最长回文子串(中等)

### 题目

[题目链接](https://www.nowcoder.com/practice/b4525d1d84934cf280439aeecc36f4af?tpId=295&tqId=25269&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

对于长度为n的一个字符串A（仅包含数字，大小写英文字母），请设计一个高效算法，计算其中最长回文子串的长度。

数据范围： 1≤*n*≤1000

要求：空间复杂度 O(1)，时间复杂度 O(n^2^)

进阶: 空间复杂度 O(n)，时间复杂度 O(n)

示例：

```
示例1：
输入："ababc"
返回值：3
说明：最长的回文子串为"aba"与"bab"，长度都为3
示例2：
输入："abbba"
返回值：5
示例3：
输入："b"
返回值：1
```

### 解法1 中心扩展

```Java
import java.util.*;
public class Solution {
    public int fun(String s, int begin, int end){
        //每个中心点开始扩展
        while(begin >= 0 && end < s.length() && s.charAt(begin) == s.charAt(end)){ 
            begin--;
            end++;
        }
        //返回长度
        return end - begin - 1; 
    } 
    public int getLongestPalindrome (String A) {
        int maxlen = 1;
        //以每个点为中心
        for(int i = 0; i < A.length() - 1; i++) 
            //分奇数长度和偶数长度向两边扩展
            maxlen = Math.max(maxlen, Math.max(fun(A, i, i), fun(A, i, i + 1))); 
        return maxlen;
    }
}
```

空间复杂度 O(1)，时间复杂度 O(n^2^)

### 解法2 manacher算法（动态规划）（没看懂）



## BM74 数字字符串转化成IP地址(中等)

### 题目

[题目链接](https://www.nowcoder.com/practice/ce73540d47374dbe85b3125f57727e1e?tpId=295&tqId=653&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

现在有一个只包含数字的字符串，将该字符串转化成IP地址的形式，返回所有可能的情况。

例如：

给出的字符串为"25525522135",

返回["255.255.22.135", "255.255.221.35"]. (顺序没有关系)

数据范围：字符串长度 0≤*n*≤12

要求：空间复杂度 O(n!),时间复杂度 O(n!)

注意：ip地址是由四段数字组成的数字序列，格式如 "x.x.x.x"，其中 x 的范围应当是 [0,255]。

示例：

```
示例1：
输入："25525522135"
返回值：["255.255.22.135","255.255.221.35"]
示例2：
输入："1111"
返回值：["1.1.1.1"]
示例3：
输入："000256"
返回值：[]
```

### 解法

枚举三个点的位置。

```Java
import java.util.*;
public class Solution {
    public ArrayList<String> restoreIpAddresses (String s) {
        ArrayList<String> res = new ArrayList<String>();
        int n = s.length();
        //遍历IP的点可能的位置（第一个点）
        for(int i = 1; i < 4 && i < n - 2; i++){ 
            //第二个点的位置
            for(int j = i + 1; j < i + 4 && j < n - 1; j++){ 
                //第三个点的位置
                for(int k = j + 1; k < j + 4 && k < n; k++){ 
                    //最后一段剩余数字不能超过3
                    if(n - k >= 4) 
                        continue; 
                    //从点的位置分段截取，substring(a, b)方法获取范围[a, b)
                    String a = s.substring(0, i);
                    String b = s.substring(i, j);
                    String c = s.substring(j, k);
                    String d = s.substring(k);
                    //IP每个数字不大于255，parseInt()方法将字符串转为整型
                    if(Integer.parseInt(a) > 255 || Integer.parseInt(b) > 255 || Integer.parseInt(c) > 255 || Integer.parseInt(d) > 255)
                        continue;
                    //排除前导0的情况
                    if((a.length() != 1 && a.charAt(0) == '0') || (b.length() != 1 && b.charAt(0) == '0') ||  (c.length() != 1 && c.charAt(0) == '0') || (d.length() != 1 && d.charAt(0) == '0'))
                        continue;
                    //组装IP地址
                    String temp = a + "." + b + "." + c + "." + d; 
                    res.add(temp);
                }
            }
        }
        return res;
    }
}
```



## BM75 编辑距离(一)(较难)

### 题目

[题目链接](https://www.nowcoder.com/practice/6a1483b5be1547b1acd7940f867be0da?tpId=295&tqId=2294660&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D295)

给定两个字符串 str1 和 str2 ，请你算出将 str1 转为 str2 的最少操作数。

你可以对字符串进行3种操作：

1.插入一个字符

2.删除一个字符

3.修改一个字符。

字符串长度满足 1≤*n*≤1000 ，保证字符串中只出现小写英文字母。

示例：

```
示例1：
输入："nowcoder","new"
返回值：6
说明：
"nowcoder"=>"newcoder"(将'o'替换为'e')，修改操作1次
"nowcoder"=>"new"(删除"coder")，删除操作5次   
示例2：
输入："intention","execution"
返回值：5
说明：一种方案为:
因为2个长度都是9，后面的4个后缀的长度都为"tion"，于是从"inten"到"execu"逐个修改即可  
```

### 解法 动态规划

```Java
import java.util.*;
public class Solution {
    public int editDistance (String str1, String str2) {
        int n1 = str1.length();
        int n2 = str2.length();
        //dp[i][j]表示到str1[i]和str2[j]为止的子串需要的编辑距离
        int[][] dp = new int[n1 + 1][n2 + 1]; 
        //初始化边界
        for(int i = 1; i <= n1; i++) 
            dp[i][0] = dp[i - 1][0] + 1;
        for(int i = 1; i <= n2; i++)
            dp[0][i] = dp[0][i - 1] + 1;
        //遍历第一个字符串的每个位置
        for(int i = 1; i <= n1; i++) 
            //对应第二个字符串每个位置
            for(int j = 1; j <= n2; j++){ 
                //若是字符相同，此处不用编辑
                if(str1.charAt(i - 1) == str2.charAt(j - 1)) 
                    //直接等于二者前一个的距离
                    dp[i][j] = dp[i - 1][j - 1]; 
                else
                    //选取增加1位、添加1位、减少1位中最小的距离，加上此处编辑距离1
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1; 
            }
        return dp[n1][n2]; 
    }
}
```

