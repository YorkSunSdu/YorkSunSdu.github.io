---
layout: post
title: 操作系统第1、2、3章概念总结
date: 2022-04-03
tags: 操作系统
---

## 第一章 导论

1. **计算机系统四个组成部分**

   1. 计算机硬件
   2. 操作系统
   3. 系统程序
   4. 用户

2. 区分系统程序与应用程序

   1. 系统程序部署内核的一部分，但仍与操作系统相关联。
   2. 应用程序不与系统的操作相关联。

3. **操作系统概念**

   操作系统是一组控制和管理计算机硬件和软件资源、合理地对各类作业进行调度，以及方便用户的程序集合。

4. 操作系统的目标

   1. 执行用户程序，更容易地解决用户问题。
   2. 使计算机系统使用方便。
   3. 有效地使用计算机硬件。
   
5. **操作系统可看作资源分配器**

   计算机系统可能有许多资源，用来解决CPU时间、内存空间、文件存储空间、I/O设备等问题。<u>操作系统管理这些资源</u>。面对许多甚至冲突的资源请求，操作系统必须决定<u>如何为各个程序和用户分配资源</u>，以便计算机系统能有效而公平地运行。

6. **引导程序的概念、存储位置**

   <u>引导程序是计算机打开电源或重启时运行的初始化程序。</u>通常位于ROM或EPROM中，称为计算机硬件中的<u>固件</u>。它初始化系统的所有部分，包括CPU寄存器、设备控制器和内存内容。

7. <u>中断向量的作用</u>

   由于只有少量的预先定义的中断，所以可使用<u>中断处理子程序的指针表</u>，即中断向量。这样通过指针表可间接调用中断处理子程序，而不需要通过其它子程序。

8. 主存不适合做永久的程序存储和备份的原因

   1. 内存<u>太小</u>，不能永久地存储所有需要的程序和数据；
   2. 内存是<u>易失性</u>存储设备，当掉电时会失去所有内容。

9. 设备控制器和设备驱动程序

   1. 通用计算机系统由一个CPU和多个<u>设备控制器</u>组成，它们通过共同的总线连接起来。每个设备控制器负责特定类型的设备。设备控制器负责在其所控制的外部设备与本地缓冲存储之间进行<u>数据传递</u>。
   2. 通常操作系统为每个设备控制器提供一个<u>设备驱动程序</u>。这些设备驱动程序理解设备控制器，并<u>提供</u>一个设备与其余操作系统的<u>统一接口</u>。

10. 两个视角

       1. 用户视角
       2. 系统视角

11. 硬中断（interrupt）

    interrupt是一种在系统内硬件设备产生，又称外部中断（相对于CPU）。

12. 软中断（trap）

    Trap是指令产生的中断，又称内部中断（相对于CPU）。

13. 存储结构

    1. 主存：CPU可以直接访问的大型存储介质。
    2. 辅存：非易失性大存储容量的主存储器的扩展。（又称二级存储）
    3. 磁盘：最常用的辅存。磁盘表面逻辑上划分为磁道，再细分为扇区。磁盘控	制器决定设备和计算机之间的逻辑交互。

14. **DMA（直接内存访问）**

    用于高速I/O设备，能够以接近内存速度传送信息。

    设备控制器<u>无需CPU干预</u>直接将数据块从缓冲存储器（设备控制器中的存储）直接传输到主存，每个块只产生一个中断，而不是每个字节的一个中断（块设备）。

15. 计算机系统

       1. 单处理器系统

    2. **多处理器系统（并行系统、紧耦合系统）**

       1. 定义：多处理器系统有多个紧密通信的CPU，它们共享计算机总线，有时还有时钟、内存和外设等。
       2. 优点：增加吞吐量、规模经济、增加可靠性。
       3. 分类：
          1. **非对称多处理**：每个处理器都有各自特定的任务。一个主处理器控制系统，其他处理器或者向主处理器要任务或做预先定义的任务。
          2. **对称多处理**：每个处理器都要完成操作系统中的所有任务。所有处理器对等，处理器之间没有主-从关系。

    3. **集群系统**

       定义：与多处理器系统一样，集群系统将<u>多个CPU</u>集中起来完成计算任务。然而，集群系统与多处理器系统不同，它是由<u>两个或多个独立的系统耦合</u>起来的。集群计算机共享存储并通过局域网络连接或更快的内部连接。

       集群通常用来提供<u>高可用服务</u>，这意味着即时集群中的一个或多个系统出错，服务仍然继续。

16. 多核处理比把每个处理器放在自己芯片上更有效的原因

    <u>同一芯片</u>的处理器之间的通信比不同芯片上的处理器<u>更快</u>。

17. 物理内存、虚拟内存和逻辑内存的区别

    1. 物理内存：可供机器执行操作的内存，如cache, RAM等。
    2. 虚拟内存：是一种方法，通过<u>使用磁盘内存</u>作为主存的后备存储，可执行需要比物理内存中可用空间<u>更大</u>的程序。
    3. 逻辑内存：是计算机<u>不同类型内存的抽象</u>，它允许程序员和应用程序简化内存的视图，并使之不必担心内存存储的限制。

18. **描述操作系统的两种操作模式（双重模式）**

    为了确保操作系统的正常执行，许多操作系统所采取的方法是提供<u>硬件支持</u>以允许区分各种执行模式。在计算机系统中增加一个称为<u>模式位</u>的位以表示当前模式：<u>系统模式（又称监督程序模式、特权模式）和用户模式，分别用0和1表示</u>。当计算机系统表示用户应用程序正在执行，系统处于用户模式。当用户应用程序需要操作系统的服务（通过系统调用），它必须从用户模式转换过来执行请求。

    将能引起损害的机器指令作为<u>特权指令</u>。用户模式下想要执行特权指令，硬件不会执行，会认为是非法指令，并以陷阱的形式通知操作系统。

19. 操作系统结构

    操作系统最重要的一点是要有<u>多道程序处理能力</u>。多道程序设计通过组织作业（编码或数据）使CPU总有一个作业在执行，从而提高了CPU的利用率。

20. 缓存一致性

    在<u>多处理器环境</u>中，相同数据的两个副本可能驻留在每个CPU的本地缓存中。当一个CPU改变了数据，另一个CPU的缓存必须接收到更新的数据。<u>缓存一致性</u>包括确保多个缓存存储数据的最新版本。

21. 操作系统的三种基本类型

    1. **Batch systems（批处理系统）**
    2. **Time-sharingsystems（分时系统）**
    3. **Real timesystems（实时系统）**

22. **批处理系统**

    1. 工作方式：用户将作业交给系统操作员，系统操作员将许多用户的作业<u>组成一批作业(jobs)</u>之后输入到计算机中，在系统中形成一个自动转接的连续的作业流，系统自动、依次执行每个作业。最后由操作员将作业结果交给用户。操作系统自动将控制从一个任务转到下一个任务。

    2. 分类：单道批处理系统、多道批处理系统

    3. 批处理操作系统<u>优点</u>：作业流程自动化、效率高、吞吐量高。

    4. 批处理操纵系统<u>缺点</u>：无交互手段、调试程序困难。

23. **分时系统- 交互式计算**

      分时系统（或多任务）是多道程序设计的延伸。

      <u>共享</u>需要一种交互计算机系统，它能提供<u>用户与系统之间的直接通信</u>。<u>响应时间短</u>（通常小于一秒钟）。

      由于每个动作或命令都较短，每个用户只需少量CPU时间，用户之间切换时间短，所以用户会感觉整个系统为自己所用。

24. **实时系统**

    1. 定义：实时操作系统是保证在一定时间限制内完成特定功能的操作系统。

    2. 分类：
       1. <u>硬实时系统</u>：硬实时要求在规定的时间内必须完成操作，这是在操作系统设计时保证的（不按时间约束完成意味着失败）。（又称强实时系统）
       2. <u>软实时系统</u>：软实时则只要按照任务的优先级，尽可能快地完成操作即可，（不按时完成意味着“不好”）。（又称准实时系统、若实时系统）。

25. 保护和安全的区别

    1. <u>保护</u>是一种<u>控制</u>进程或用户对计算机系统资源的<u>访问</u>的机制；
    2. <u>安全</u>的主要工作是<u>防止</u>系统受到内部或外部<u>攻击</u>。

26. 描述两种服务器系统

    1. <u>计算服务器系统</u>提供了一个<u>接口</u>，以<u>接收</u>用户所发送的执行操作的<u>请求</u>（如读数据），<u>执行</u><u>操作</u>，并将操作结果返回给客户机。运行响应客户机数据请求的数据库的服务器就是这样的例子。
    2. <u>文件服务器系统</u>提供文件系统接口，以便客户机能创建、更新、访问和删除<u>文件</u>。Web服务器就是该系统的一个例子，它将文件传送到正在运行Web浏览器的客户机。



## 第二章 操作系统结构

1. **操作系统服务**

   用户界面（一种是命令行界面；另一种是批界面，最为常用的是图形用户面）、程序执行、I/O操作、文件系统操作、通信、错误检测、资源分配、统计、保护和安全。

2. 操作系统的**用户界面**：

   **命令解释程序（CLI）、图形用户界面（GUI）**

   命令解释程序主要作用：获取并执行用户指定的下一条命令。

3. 命令解释器可以通过两种不同的方式处理命令，一种方法是允许命令解释器包含执行命令所需的代码；另一种方法是通过系统程序实现命令。比较这两种方法。

   1. 第一种方法中，用户发出命令是，解释器<u>跳转到相应代码段</u>，执行命令，并将控制权返回给用户。优点是<u>速度快</u>，总体简单；缺点是新命令需<u>重写解释程序</u>，经过多次修改，解释程序可能变得混乱、庞杂。
   2. 第二种方法中，解释器将适当的程序连同适当的<u>参数</u>装入内存。优点是可以在<u>不改变命令解释器</u>的情况下添加新命令；缺点是<u>速度慢</u>，将参数从解释器传给系统解释程序笨拙麻烦。

4. **系统调用（System Call）**

   操作系统内核提供一系列预定功能，通过一组称为系统调用的接口呈现给编程人员，系统调用把应用程序的请求传给内核，系统调用相应的内核函数完成所需的处理，将处理结果返回给应用程序。

5. 描述API、系统调用接口和操作系统的关系

   绝大多数程序设计语言在运行时支持系统提供了<u>系统调用接口</u>，作为应用程序与操作系统的系统调用的链接。系统调用接口<u>截取API的函数调用</u>，并调用操作系统中相应的系统调用。因此，通过API操作系统接口的绝大多数细节被隐藏起来，并<u>被执行支持库所管理</u>。

6. **向操作系统传递参数的三种方法**

   1. 通过<u>寄存器</u>来传递参数。
   2. 若参数数量比寄存器多，<u>参数通常存在内存的块和表中</u>，并将块的地址通过寄存器来传递。
   3. 参数也可以通过程序放在或压入<u>堆栈</u>中，并通过操作系统弹出。

7. 系统程序分类：

   文件管理、状态信息、文件修改、程序语言支持、程序装入和执行、通信。

8. **操作系统设计和实现**：

   1. **设计目标需求**：用户目标和系统目标
      1. 用户目标：系统应该方便和容易使用、容易学习、可靠、安全和快速。
      2. 系统目标：操作系统应该容易设计、实现和维护，也应该灵活、可靠、高效且没有错误。
   2. 机制和策略：机制决定如何做，策略决定做什么

9. 使用高级语言实现操作系统的好处

   1. 代码编写更<u>快</u>，更为<u>紧凑</u>，更容易理解和调试。
   2. 编译技术的改进使得只要通过<u>重新编译</u>就可改善整个操作系统的生成代码。
   3. 操作系统将更容易<u>移植</u>到不同平台上。

10. **操作系统结构**

   简单结构、分层方法、微内核、模块、虚拟机

   1. 简单结构

      MS-DOS、原始的UNIX操作系统

   2. 分层方法

      定义：操作系统分成若干层（级）。最底层（层0）为硬件，最高层（层N）为用户接口。（理想方法，<u>困难在于如何划分层</u>）

   3. 微内核

      微内核方法将所有非基本部分从内核中移走，并将它们实现为系统或用户程序，这样得到了更小的内核。

      微内核的主要功能是使客户程序和运行在用户空间的各种服务之间进行通信。

      优点：

      1. 便于扩充操作系统。所有新服务可以在<u>用户空间</u>增加，因而并<u>不需要修改内核</u>。
      2. 很容易从一种硬件平台设计<u>移植</u>到另一种硬件平台设计。
      3. 绝大多数服务是作为用户而不是内核进程来运行的，因此微内核提供了更好的<u>安全性和可靠性</u>。

      缺点：微内核必须忍受由于系统总功能的开销增加而导致系统<u>性能的下降</u>。

   4. 模块：

      大多数现代操作系统按模块方式实现内核

      采用面向对象的方法

      每个核心组件是分开的

      每部分与已知接口的其他部分通信

      可以是动态加载方式，每部分根据需要加载到内核

      总之，类似于层，但更灵活。

      解释为什么模块化内核可能是当前操作系统设计技术中最好的：

      模块化方法<u>结合了分层设计技术和微内核设计技术的优点</u>。在模块化设计中，内核只需要有能力执行所需的<u>功能</u>，并知道如何在模块之间<u>通信</u>。但如果内核中需要更多的功能，那么用户可以<u>动态地将模块加载</u>到内核中。内核可以具有定义良好、受保护的<u>接口</u>的部分，这是分层系统中需要的属性。通过允许模块之间进行<u>通信</u>，可以实现更大的<u>灵活性</u>。

   5. 虚拟机

      虚拟机（VirtualMachine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的“完整”计算机系统。

   

## 第三章 进程

1. **进程概念**

   <u>进程是执行中的程序</u>。进程还包括当前活动信息：通过程序计数器的值和处理器寄存器的内容等来表示。另外，进程内存影像包括进程堆栈段（包括临时数据，如函数参数、返回地址和局部变量）和数据段（包括全局变量），包括堆，是在进程运行期间动态分配的内存。

2. 进程与程序是截然不同的两个概念

   一个程序可以对应多个进程(Oneprogram can be several processes)

   一个进程也可以由多个程序段共同完成一项任务（接力）

3. **进程五个特征**（而程序不具备）

   1. <u>动态性</u>：是进程的最基本的特征，表现在进程由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡。

   2. <u>并发性</u>：多个进程实体同存于内存中，能在一段时间内同时执行。

   3. <u>独立性</u>：进程实体是一个能独立运行的基本单位，同时也是系统中独立获得资源和独立调度的基本单位。

   4. <u>异步性</u>：指进程按各自独立的、不可预知的速度向前推进；或者说，进程按异步方式运行。

   5. <u>结构特征</u>：从结构上看，进程实体由程序段、数据段以及进程控制块组成。三部分也称为进程影像。

4. **进程状态**
   
   1. <u>新建（new）</u>：进程正在被创建。
   
   2. <u>运行（running）</u>：指令正在被执行。
   
   3. <u>等待（waiting）</u>：进程等待某个时间的发生（如I/O完成或收到信号）。
   
   4. <u>就绪（ready）</u>：进程等待分配处理器。
   
   5. <u>终止（terminated）</u>：进程完成执行
   
     进程状态图

<img src="/images/operatingSystemChapter1-3imgs/进程状态图.png" alt="img" style="zoom: 50%;" /> 

 

5. **进程控制块**

   每个进程在操作系统内对应一<u>进程控制块（PCB，process control block）</u>。

   1. 概念：系统为了管理进程设置的一个专门的数据结构，用它来<u>记录进程的外部特征，描述进程的运动变化过程</u>。

   2. 要点：
      1. 系统利用PCB来控制和管理进程，所以<u>PCB是系统感知进程存在的唯一标志</u>。
      2. 进程与PCB是<u>一一对应</u>的。
      3. 通常<u>进程队列</u>是进程所对的<u>PCB队列</u>。
      4. 操作系统通过PCB来感知进程的存在。

6. **PCB表**

   系统把所有PCB组织在一起，并把它们<u>放在内存的固定区域</u>，就构成了PCB表。PCB表的大小决定了<u>系统中最多可同时存在的进程个数</u>，称为系统的<u>并发度</u>。

   结构：

   1. 链接结构：同一状态进程的PCB组成一个链表，不同状态的进程对应多个不同的链表。（就绪链表、阻塞链表……）

   2. 索引结构：对具有相同状态的进程，分别设置各自的PCB索引表，表明PCB在PCB表中的地址。

      ...

7. **进程调度**

   多道程序设计的目的是<u>无论何时都有进程在运行，从而使CPU利用率达到最大化</u>。

   分时系统的目的是<u>在进程之间快速切换CPU以便用户在程序运行时能与其进行交互</u>。

   为达到此目的，进程调度选择一个可用的进程到CPU上执行。单处理器系统从不会有超过一个进程在运行。如果有多个进程，那么余下的则需要等待CPU空闲并重新调度。

8. **调度程序**

   **长期调度程序**（或作业调度程序）

   **短期调度层序**（或CPU调度程序）

   这两个调度程序的主要差别是它们执行的频率。

   短期调度程序必须<u>频繁为CPU选择新进程</u>。

   长期调度程序<u>控制多道程序设计的程度</u>（内存中的进程数量）。

   **中期调度程序**（又名交换）核心思想：调度程序根据一定策略临时把内存中的某个进程换出到外存或者把外存中的进程换入内存的过程。（一定程度上降低长期调度的设计或策略难度）。
   ![img](/images/operatingSystemChapter1-3imgs/三种调度.png) 
   <img src="/images/operatingSystemChapter1-3imgs/作业调度.png" alt="img" style="zoom:80%;" /> 

	<u>短期调度</u>执行的频率最高。短期调度在内存作业中选择就绪执行的作业，并为他们分配CPU。<u>中期调度</u>作为一种中等程度的调度程序，尤其被用于分时系统，一个交换方案的实施，将部分运行程序移出内存，之后，从中断处继续执行，从而改善进程组合或者因内存要求的改变引起了可用内存的过度使用而需要释放内存。<u>长期调度</u>确定哪些作业调入内存以执行. 它们主要的不同之处是它们的执行的频率。短期调度必须经常调用一个新进程，由于在系统中，长期调度处理移动的作业时，并不频繁被调用，可能在进程离开系统时才被唤起。

9. **上下文切换**

   将CPU切换到另一个进程需要<u>保存当前进程的状态</u>并<u>恢复另一个进程的状态</u>，这一任务称为上下文切换。

10. **进程操作**

    进程标识符（pid）

    通过fork()系统调用，可创建新进程。

    新进程通过<u>复制原来的地址空间</u>形成。

    <u>子进程返回0，父进程返回大于0，错误返回-1。</u>

11. **fork()的功能**

    内核为子进程做一个父进程的<u>上下文的拷贝</u>（<u>复制父进程的PCB作为子进程的PCB</u>），<u>子进程与父进程共享子进程创建之前父进程所有的资源</u>，<u>父进程和子进程在不同的地址空间上运行</u>。

12. **fork()的几个要点**

    <u>父子进程具有独立的内存空间</u>。

    父子进程资源的共享与分离：<u>父进程中在fork之前创建的变量——先继承，后分离</u>，<u>子进程继承了父进程的私有变量，作为自己的私有变量</u>；<u>fork之后各自创建的变量——完全分离</u>。

    子进程继承了父进程的所有资源，其中包括父进程的这些私有变量，<u>但继承以后互相不能访问</u>。

13. **两种进程间通信机制**

    1. <u>共享内存</u>：允许以最快的速度进行方便的通信，在计算机中可以达到内存的速度，等等。

    2. <u>消息传递</u>：对于交换较少数量的数据很有用，因为不需要避免冲突，对于计算机间的通信，消息传递也比共享内存更易于实现，

<div style="color: red; font-size:24px">商业转载请联系博主获得授权，非商业转载请注明出处！</div>

分享结束，大家辛苦了。散会！

